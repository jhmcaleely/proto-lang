// Yarg implementation of Conway's Life
// https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
//
// A 2D matrix of cells, which contain a running instance
// of Conway's Life.
//
// The neighbourhood (n) around a cell (c) is consulted to
// see if the cell should maintain or change state
//
// nnn
// ncn
// nnn

// characters handing for ascii state reports
var live = 1;
var dead = 0;

var columns = 10;
var rows = 10;

var randseed = 0d1;

fun rand() {

    // https://github.com/kraj/uClibc/blob/master/libc/stdlib/rand_r.c#L25

    var next = seed;
    var result;

    next = next * 0d1103515245;
    next = next + 0d12345;
    result = (next / 0d65536) % 0d2048;

    next = next * 1103515245;
    next = next + 12345;
    result = result << 0d10;
    result = result ^ ((next / 0d65536) % 0d1024);

    next = next * 0d1103515245;
    next = next + 0d12345;
    result = result << 0d10;
    result = result ^ ((next / 0d65536) % 0d1024);

    randseed = next;
    return next;
}

fun random_state() {

    if (rand() > 0d4294967295 / 0d2) {
        return 0;
    }
    else {
        return 1;
    }
}

fun make_row(cols) {
    var row = make_array(cols);
    for (var i = 0; i < cols; i = i + 1) {
        row[i] = random_state();
    }
    return row;
}

fun make_world(cols, lines) {
    var col = make_array(lines);
    for (var i = 0; i < cols; i = i + 1) {
        col[i] = make_row(cols);
    }
    return col;
}

fun row_count(world) {
    return rows;
}

fun col_count(world) {
    return columns;
}

fun get_cell(world, x, y) {
    return world[y][x];
}

fun set_cell(world, x, y, state) {
    world[y][x] = state;
}

fun count(array, val) {
    result = 0;
    for (var i = 0; i < len(array); i = i + 1) {
        if (array[i] == val) {
            result = result + 1;
        }
    }
    return result;
}

fun next_state(state, neighbourhood) {
    new_state = dead;
    alive_neighbours = count(neighbourhood, live);
    
    if (state == live and (alive_neighbours == 2 or alive_neighbours == 3)) {
        new_state = live;
    }
    else if (state == dead and alive_neighbours == 3) {
        new_state = live;
    }

    return new_state;
}

fun next_generation(world) {
    var next_gen = make_array(colsumns * lines);
    for (var l = 0; l < row_count(world); l = l + 1) {
        for (var c = 0; c < col_count(world); c = c + 1) {
            neighbourhood = neighbours(world, line, col);
            state = get_cell(world, col, line);
            next_gen[c + (l * row_count(world))] = state;
        }
    }

    return next_gen;
}


fun adjacent_line(world, line, col) {
    return [line[(col + x) % col_count(world)] for x in range(-1, 2)];
}

fun neighbours(world, line, col) {
    var n;
    col_c = col_count(world);
    row_c = row_count(world);
    
    n.extend(adjacent_line(world, world[(line - 1) % row_c], col));

    n.append(get_cell(world, (col-1) % col_c, line));
    n.append(get_cell(world, (col+1) % col_c, line));

    n.extend(adjacent_line(world, world[(line + 1) % row_c], col));
    return n;
}
